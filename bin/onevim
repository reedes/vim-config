#!/bin/sh
#
# This shell script passes all its arguments to the binary inside the
# MacVim.app application bundle.  If you make links to this script as view,
# gvim, etc., then it will peek at the name used to call it and set options
# appropriately.
#
# Based on a script by Wout Mertens and suggestions from Laurent Bihanic.  This
# version is the fault of Benji Fisher, 16 May 2005 (with modifications by Nico
# Weber and Bjorn Winckler, Aug 13 2007).

# Name       : onevim
# Description: Use MacVim with server-driven instances
#
# Author     : github.com/reedes
# Created    : February 17, 2014
#
# See Damian Conway's work on detecting multiple editing instances
#
# $ gvim --remote-send "<C-\><C-n>:if &ft == 'nerdtree'|wincmd p|endif|edit filename<CR>"
# "help view" for startup modes
# view     vim -R     Start in read-only mode (see |-R|).       *view*
# gvim     vim -g     Start the GUI (see |gui|).          *gvim*
# gex      vim -eg    Start the GUI in Ex mode.       *gex*
# gview    vim -Rg    Start the GUI in read-only mode.      *gview*
# rvim     vim -Z     Like "vim", but in restricted mode (see |-Z|)   *rvim*
# rview    vim -RZ    Like "view", but in restricted mode.    *rview*
# rgvim    vim -gZ    Like "gvim", but in restricted mode.    *rgvim*
# rgview   vim -RgZ   Like "gview", but in restricted mode.   *rgview*
# evim     vim -y     Easy Vim: set 'insertmode' (see |-y|)     *evim*
# eview    vim -yR    Like "evim" in read-only mode     *eview*
# vimdiff  vim -d     Start in diff mode |diff-mode|
# gvimdiff vim -gd    Start in diff mode |diff-mode|
# :hide            - close current window
# :only            - keep only this window open

# ===================================
# Functions
# ===================================

# obtain the full path of a filename
realpath() {
    [[ $1 = /* ]] && echo "$1" || echo "$PWD/${1#./}"
}

containsElement() {
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}

# ===================================
# Entry point
# ===================================

# First, check "All the Usual Suspects" for the location of the Vim.app bundle.
# You can short-circuit this by setting the VIM_APP_DIR environment variable
# or by un-commenting and editing the following line:
VIM_APP_DIR=/usr/local/Cellar/macvim/7.4-72

if [ -z "$VIM_APP_DIR" ]
then
  myDir="`dirname "$0"`"
  myAppDir="$myDir/../Applications"
  for i in ~/Applications ~/Applications/vim $myDir $myDir/vim $myAppDir $myAppDir/vim /Applications /Applications/vim /Applications/Utilities /Applications/Utilities/vim; do
    if [ -x "$i/MacVim.app" ]; then
      VIM_APP_DIR="$i"
      break
    fi
  done
fi
if [ -z "$VIM_APP_DIR" ]
then
  echo "Sorry, cannot find MacVim.app.  Try setting the VIM_APP_DIR environment variable to the directory containing MacVim.app."
  exit 1
fi
binary="$VIM_APP_DIR/MacVim.app/Contents/MacOS/Vim"

# Next, peek at the name used to invoke this script, and set options
# accordingly.

name="`basename "$0"`"
gui=
opts=

# GUI mode, implies forking
case "$name" in m*|g*|rm*|rg*) gui=true ;; esac

# Restricted mode
case "$name" in r*) opts="$opts -Z";; esac

# vimdiff, view, and ex mode
case "$name" in
  *vimdiff)
    opts="$opts -dO"
    ;;
  *view)
    opts="$opts -R"
    ;;
  *ex)
    opts="$opts -e"
    ;;
esac

available_servers=($(exec "$binary" --serverlist}))
echo "AVAILABLE SERVERS $available_servers"
if [ $? -ne 0 ]; then
  echo "ERROR: your mvim lacks client-server capability"
  exit(1)
fi

# attempt to detect an explicit servername
server_name=
while [ "`echo $1 | cut -c1`" = "-" ]
do
  case "$1" in
      --servername)
          server_name=$2
          shift 1
          ;;
  esac
done
echo "server_name=$server_name remaining args: [$@]"

exit(10)

# If no explicit server, choose one from list
# but if none, choose VIM.
if [ -z "$server_name" ] ; then
  #server=$(cut -d" " -f2)
  #server="${available_servers[@]:0:1}"
  server="VIM"
fi

# determine the edit cmd from the name of the script
# TODO view, sview
more_keys=
case "`basename "$0"`" in
v*)   edit_cmd="vsplit"
      more_keys="<c-w>L"     # right
      ;;
t*)   edit_cmd="tabedit"
      ;;
s*)   edit_cmd="split"
      more_keys="<c-w>="     # equal
      ;;
*)    edit_cmd="edit"
      ;;
esac

server_exists=$(containsElement "$server_name" "${available_servers[@]}")

if $server_exists ; then
  if [ $# -gt 1 ] ; then
    # load many files
    mvim --server-name="$server_name" "$@" --remote-send ":call foreground()<CR>"
  else
    keys=
    if [ -n "$1" ] ; then
      # load single file (which may not yet exist) in split/tab
      full_path=$(realpath "$1")
      keys="<C-\><C-n>:$edit_cmd $full_path<CR>"
    fi
    mvim --server-name="$server_name" --remote-send ":call foreground()<CR>$keys$more_keys"
  fi
elif [ -n "$@" ] ; then
  # attempt to edit in a new server instance
  mvim --server-name="$server_name" --remote-silent "$@"
else
  # punt, because --remote-silent complains if no files
  mvim #--server-name="$server_name" --remote-send ":call foreground()<CR>"
fi

# Last step:  fire up vim.
# The program should fork by default when started in GUI mode, but it does
# not; we work around this when this script is invoked as "gvim" or "rgview"
# etc., but not when it is invoked as "vim -g".
if [ "$gui" ]; then
  # Note: this isn't perfect, because any error output goes to the
  # terminal instead of the console log.
  # But if you use open instead, you will need to fully qualify the
  # path names for any filenames you specify, which is hard.
  exec "$binary" -g $opts ${1:+"$@"}
else
  exec "$binary" $opts ${1:+"$@"}
fi

