#!/bin/bash
# Name       : onevim
# Description: Launch against a single server-driven instance of Vim
#
# Author     : github.com/reedes
# Created    : February 18, 2014
#
# This shell script passes all its arguments to the binary inside the
# MacVim.app application bundle.  If you make links to this script as view,
# gvim, etc., then it will peek at the name used to call it and set options
# appropriately.
#
# Based on a script by Wout Mertens and suggestions from Laurent Bihanic.  This
# version is the fault of Benji Fisher, 16 May 2005 (with modifications by Nico
# Weber and Bjorn Winckler, Aug 13 2007).
#
# Adapted by Reed Esau for use with server instances, Feb 18 2014.

# obtain the full path of a filename
realpath() {
  [[ $1 = /* ]] && echo "$1" || echo "$PWD/${1#./}"
}

# escape any single quotes in an argument
quote() {
  echo "$1" | sed -e "s,','\\\\'',g"
}

# ===================================
# Entry point
# ===================================

# First, check "All the Usual Suspects" for the location of the Vim.app bundle.
# You can short-circuit this by setting the VIM_APP_DIR environment variable
# or by un-commenting and editing the following line:
VIM_APP_DIR=/usr/local/Cellar/macvim/7.4-72

if [ -z "$VIM_APP_DIR" ]
then
  myDir="`dirname "$0"`"
  myAppDir="$myDir/../Applications"
  for i in ~/Applications ~/Applications/vim $myDir $myDir/vim $myAppDir $myAppDir/vim /Applications /Applications/vim /Applications/Utilities /Applications/Utilities/vim; do
    if [ -x "$i/MacVim.app" ]; then
      VIM_APP_DIR="$i"
      break
    fi
  done
fi
if [ -z "$VIM_APP_DIR" ]
then
  echo "Sorry, cannot find MacVim.app.  Try setting the VIM_APP_DIR environment variable to the directory containing MacVim.app."
  exit 1
fi
binary="$VIM_APP_DIR/MacVim.app/Contents/MacOS/Vim"

# Next, peek at the name used to invoke this script, and set options
# accordingly.

name="`basename "$0"`"
gui=
opts=

# GUI mode, implies forking
case "$name" in m*|g*|rm*|rg*) gui=true ;; esac

# Restricted mode
case "$name" in r*) opts="$opts -Z";; esac

# vimdiff, view, and ex mode
case "$name" in
  *vimdiff)
    opts="$opts -dO"
    ;;
  *view)
    opts="$opts -R"
    ;;
  *ex)
    opts="$opts -e"
    ;;
esac

# Does the user want to open as split or as a tab?
open_keys=
open_with=
case "$name" in
  *s) open_with=split
      open_keys="<c-w>="     # equal
      ;;
  *t) open_with=tabedit
      ;;
  *v) open_with=vsplit
      open_keys="<c-w>L"     # right
      ;;
  *)  open_with=edit
      ;;
esac

# query existing vim(s) to get server names
available_servers=($("$binary" --serverlist))
if [ $? -eq 0 ]; then

  # preserve original arguments, in case we must degrade
  original_args=
  for arg in "$@"; do
    original_args="${original_args:+$original_args }'$(quote "$arg")'"
  done

  # analyze the arguments provided by the user, filtering out the filenames
  server_name=
  found_remote=
  files=()
  filtered_args=
  # destructively iterates across $@
  while test -n "$*"; do
    case "$1" in
        --servername=*)
            server_name=${1:13}
            shift
            ;;
        --servername)
            shift
            server_name=$1
            shift
            ;;
        --remote*)
            # detected user-managed remote session, so bail early
            found_remote=true
            break
            ;;
        -g | -f | --nofork | -v | -e | -E | -s | -d | -y | -R | -Z | -m | -M | -b | \
        -l | -C | -N | -D | -n | -L | -A | -H | -F | --noplugin | -p* | -o* | -O* | \
        +* | -x | --serverlist | -h | --help | --version | --)
            filtered_args="${filtered_args:+$filtered_args }'$(quote "$1")'"
            shift
            ;;
        -V* | -r | -T | -u | -U | --cmd | -c | -S | -s | -W | -w | --startuptime | -i)
            # an option with an argument
            for _ in 1 2; do
              filtered_args="${filtered_args:+$filtered_args }'$(quote "$1")'"
              shift
            done
            ;;
        -*)
            # an unrecognized option of some sort which we'll ignore
            shift
            ;;
        *)
            # preserve the file for later
            files+=($1)
            shift
            ;;
    esac
  done

  if [ "$found_remote" ] ; then
    # the user is managing the remote session, so bail
    eval set -- "$original_args"
  else
    # using a filtered set of args, as this script is managing the remote session
    eval set -- "$filtered_args"

    # If no explicit server, choose first from server list,
    # but if no detected servers, choose VIM
    if [ -n "$server_name" ] ; then
      # force UPPER
      server_name=$(echo $server_name| tr '[:lower:]' '[:upper:]')
    else
      if [ ${#available_servers[@]} -gt 0 ] ; then
        server_name="${available_servers[0]}"
      else
        server_name="VIM"
      fi
    fi

    is_server_active=
    case "${available_servers[@]}" in  *"$server_name"*) is_server_active=true ;; esac

    # we had filtered server name out earlier, so re-add it
    opts="$opts --servername $server_name"

    if [ "$is_server_active" ] ; then
      if [ ${#files[@]} -gt 1 ] ; then
        # more than one file specified, so load them all (ignoring open_with)
        # TODO should we use --remote-tab here when open_with=tabedit?
        opts="$opts --remote-send \"<c-\><c-n>:call<space>foreground()<CR>\" -- ${files[*]}"
      else
        keys=
        one_file=${files[0]}
        if [ -n "$one_file" ] ; then
          # load single file (which may not yet exist) in split/tab/etc.
          # TODO do we need to escape file path with <space> ?
          full_path=$(realpath "$one_file")
          keys="<c-\><c-n>:$open_with<space>$full_path<CR>"
        fi
        opts="$opts --remote-send \"<c-\><c-n>:call<space>foreground()<CR>$keys$open_keys\""
      fi
    else
      # attempt to edit in a new server instance
      # note that anything after --remote-silent should be a file
      # TODO should we use --remote-tab here when open_with=tabedit?
      opts="$opts --remote-silent ${files[*]}"
    fi  # is_server_active
  fi  # found_remote
fi  # server_list

# Last step:  fire up vim.
# The program should fork by default when started in GUI mode, but it does
# not; we work around this when this script is invoked as "gvim" or "rgview"
# etc., but not when it is invoked as "vim -g".
if [ "$gui" ]; then
  # Note: this isn't perfect, because any error output goes to the
  # terminal instead of the console log.
  # But if you use open instead, you will need to fully qualify the
  # path names for any filenames you specify, which is hard.
  exec "$binary" -g $opts ${1:+"$@"}
else
  exec "$binary" $opts ${1:+"$@"}
fi

