#!/bin/bash
# Name       : onevim
# Description: Use MacVim with server-driven instances
#
# Author     : github.com/reedes
# Created    : February 17, 2014
#
# See Damian Conway's work on detecting multiple editing instances
#
# $ gvim --remote-send "<C-\><C-n>:if &ft == 'nerdtree'|wincmd p|endif|edit filename<CR>"
# "help view" for startup modes
# view     vim -R     Start in read-only mode (see |-R|).       *view*
# gvim     vim -g     Start the GUI (see |gui|).          *gvim*
# gex      vim -eg    Start the GUI in Ex mode.       *gex*
# gview    vim -Rg    Start the GUI in read-only mode.      *gview*
# rvim     vim -Z     Like "vim", but in restricted mode (see |-Z|)   *rvim*
# rview    vim -RZ    Like "view", but in restricted mode.    *rview*
# rgvim    vim -gZ    Like "gvim", but in restricted mode.    *rgvim*
# rgview   vim -RgZ   Like "gview", but in restricted mode.   *rgview*
# evim     vim -y     Easy Vim: set 'insertmode' (see |-y|)     *evim*
# eview    vim -yR    Like "evim" in read-only mode     *eview*
# vimdiff  vim -d     Start in diff mode |diff-mode|
# gvimdiff vim -gd    Start in diff mode |diff-mode|
# :hide            - close current window
# :only            - keep only this window open

# ===================================
# Functions
# ===================================

# obtain the full path of a filename
realpath() {
    [[ $1 = /* ]] && echo "$1" || echo "$PWD/${1#./}"
}

containsElement() {
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}

# ===================================
# Entry point
# ===================================

if [ -z "$(which mvim)" ]; then
  echo "ERROR: no mvim available"
  exit(1)
fi

available_servers=($(mvim --serverlist))
if [ $? -ne 0 ]; then
  echo "ERROR: your mvim lacks client-server capability"
  exit(1)
fi

# TODO use --servername= instead
server_name=
while getopts s: opt
do
  case $opt in
  s)    server_name=$OPTARG
        ;;
  esac
done
shift $((OPTIND - 1))     # remove options, leave arguments
#echo "server=$server remaining $@"

# If no explicit server, choose one from list
# but if none, choose VIM.
if [ -z "$server_name" ] ; then
  #server=$(cut -d" " -f2)
  #server="${available_servers[@]:0:1}"
  server="VIM"
fi

# determine the edit cmd from the name of the script
# TODO view, sview
more_keys=
case "`basename "$0"`" in
v*)   edit_cmd="vsplit"
      more_keys="<c-w>L"     # right
      ;;
t*)   edit_cmd="tabedit"
      ;;
s*)   edit_cmd="split"
      more_keys="<c-w>="     # equal
      ;;
*)    edit_cmd="edit"
      ;;
esac

server_exists=$(containsElement "$server_name" "${available_servers[@]}")

if $server_exists ; then
  if [ $# -gt 1 ] ; then
    # load many files
    mvim --server-name="$server_name" "$@" --remote-send ":call foreground()<CR>"
  else
    keys=
    if [ -n "$1" ] ; then
      # load single file (which may not yet exist) in split/tab
      full_path=$(realpath "$1")
      keys="<C-\><C-n>:$edit_cmd $full_path<CR>"
    fi
    mvim --server-name="$server_name" --remote-send ":call foreground()<CR>$keys$more_keys"
  fi
elif [ -n "$@" ] ; then
  # attempt to edit in a new server instance
  mvim --server-name="$server_name" --remote-silent "$@"
else
  # punt, because --remote-silent complains if no files
  mvim #--server-name="$server_name" --remote-send ":call foreground()<CR>"
fi
